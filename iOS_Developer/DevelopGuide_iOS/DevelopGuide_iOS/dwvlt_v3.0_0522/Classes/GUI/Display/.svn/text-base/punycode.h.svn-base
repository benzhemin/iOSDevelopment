/* * Punycodeエンコーダ/デコーダ * * - RFC3492 を参考に、Punycodeエンコーダ/デコーダを実装したものです。 * - NAMEPREP(RFC3491)の内容は含まれません。すなわち、このクラスは入出力文字列の *   IDNAラベルとしての正当性を検証しません。 * */#ifndef ___PUNYCODE_H___#define ___PUNYCODE_H___#include <string>#include <vector>#include <algorithm>#include <functional>#include <climits>class Punycode{public:	static const unsigned int PUNYCODE_BASE			= 36;	static const unsigned int PUNYCODE_TMIN			= 1;	static const unsigned int PUNYCODE_TMAX			= 26;	static const unsigned int PUNYCODE_SKEW			= 38;	static const unsigned int PUNYCODE_DAMP			= 700;	static const unsigned int PUNYCODE_INITIAL_BIAS	= 72;	static const unsigned int PUNYCODE_INITIAL_N	= 128;	private:	Punycode()	{}		Punycode(const Punycode&)	{}	public:	/**	 * Punycode文字列をUTF8文字列にデコードする。	 * @param punycode [in] Punycode文字列	 * @return 成功すればUTF8文字列。失敗すれば空文字列	 * @note punycodeがxn--でprefixされていない場合、ASCII文字列と判断してそのまま返す。	 */	static std::string decode(const char* punycode)	{		if (!punycode || !punycode[0])	    return std::string();				if (punycode[0] && (punycode[0]=='x' || punycode[0]=='X') &&			punycode[1] && (punycode[1]=='n' || punycode[1]=='N') &&			punycode[2] && punycode[2] == '-' &&			punycode[3] && punycode[3] == '-')		{			// ACE prefixをスキップ			punycode += 4;		}		else		{			// ACE prefixがない。ASCII文字列と判断。			return std::string(punycode);		}				std::string ret;		std::vector<unsigned int> codepoints;		std::vector<unsigned int>::iterator cpinsit;				const char* it = 0;		const char* itbegin = 0;		const char* itend = 0;				const char* lastsep = strrchr(punycode, '-');		itend = punycode + strlen(punycode);				if (lastsep)		{			for (const char* p=punycode; p!=lastsep; ++p)			{				if (*(unsigned char*)p >= 0x80)				{					// non-basic chars before sep.					return std::string();				}				codepoints.push_back((unsigned int)*(unsigned char*)p);			}			itbegin = lastsep + 1;		}		else		{			// lastsepがNULLの場合、全ての文字が基本コードポイントで構成されているか、			// あるいは全く基本コードポイントが含まれていないかのいずれかである。			itbegin = punycode;		}				if (itbegin == itend)		{			if (utf32ToUtf8(ret, codepoints))			{				return ret;			}			else			{				return std::string();			}		}				unsigned int n, i, oldi, bias, w, k, digit, t, outlen, ndiff;				n = PUNYCODE_INITIAL_N;		i = 0;		bias = PUNYCODE_INITIAL_BIAS;		it = itbegin;				while (it!=itend)		{			oldi = i;			w = 1;			for (k=PUNYCODE_BASE; ; k+=PUNYCODE_BASE)			{				if (it==itend)		return std::string();				digit = decodeDigit((unsigned int)(unsigned char)*it);				++it;								if (!calcMulAdd(i, i, digit, w))				{					// overflow					return std::string();				}								if (k <= bias)				{					t = PUNYCODE_TMIN;				}				else if (k >= bias + PUNYCODE_TMAX)				{					t = PUNYCODE_TMAX;				}				else				{					t = k - bias;				}								if (digit < t)		break;								if (!calcMulAdd(w, 0, w, (PUNYCODE_BASE-t)))				{					// overflow					return std::string();				}			}						outlen = (unsigned int)codepoints.size()+1;			bias = adapt(i-oldi, outlen, oldi==0);			ndiff = i / outlen;			if (UINT_MAX - ndiff < n)			{				// overflow				return std::string();			}			n += ndiff;			i = i % outlen;			if (n < 0x80)			{				return std::string();			}			cpinsit = codepoints.begin();			advance(cpinsit, i);			codepoints.insert(cpinsit, n);			++i;		}				if (utf32ToUtf8(ret, codepoints))		{			return ret;		}		else		{			return std::string();		}	}		/**	 * UTF8文字列をPunycode文字列にエンコードする。	 * @param utf8 [in] エンコード対象のUTF-8文字列。	 * @return 成功すればPunycode文字列。失敗すると空文字列。	 * @note utf8がASCII文字のみで構成される場合、そのまま返す。	 */	static std::string encode(const char* utf8)	{		std::string ret;				std::vector<unsigned int> codepoints;		std::vector<unsigned int>::const_iterator it, itend;		unsigned int numpoints;				if (!utf8ToUtf32(codepoints, utf8))	return std::string();		numpoints = (unsigned int)codepoints.size();		itend = codepoints.end();				/////////////////////////////////////////		// encoding start		unsigned int m, n, delta, bias, h, b, q, k, t; // same meaning in RFC3492				b = 0;		for (it=codepoints.begin(); it!=itend; ++it)		{			// 基本コードポイントならそのままコピーする			if (*it < 0x80)			{				ret.push_back((char)(unsigned char)(*it));				b++;			}		}		if (b > 0 && b < numpoints)		{			ret.push_back('-');		}				if (b == numpoints)		{			// この文字列は基本コードポイントのみで構成されている。			// エンコードの必要なし。			return ret;		}				n = PUNYCODE_INITIAL_N;		delta = 0;		bias = PUNYCODE_INITIAL_BIAS;		h = b;				while (h < numpoints)		{			// n以上の値を持つコードポイントのうち、最小のものを探す。			m = UINT_MAX;			for (it=codepoints.begin(); it!=itend; ++it)			{				if (m > *it && *it >= n)				{					m = *it;				}			}						// deltaを算出			if (!calcMulAdd(delta, delta, (m-n), (h+1)))			{				// overflow				return std::string();			}			n = m;						for (it=codepoints.begin(); it!=itend; ++it)			{				if (*it < n)				{					if (delta >= UINT_MAX)					{						return std::string(); //overflow					}					delta++;				}				else if (*it == n)				{					q = delta;					for (k=PUNYCODE_BASE; ; k+=PUNYCODE_BASE)					{						if (k <= bias)						{							t = PUNYCODE_TMIN;						}						else if (k >= (bias + PUNYCODE_TMAX))						{							t = PUNYCODE_TMAX;						}						else						{							t = (k - bias);						}												if (q < t)	    break;						ret.push_back(encodeDigit(t + ((q-t) % (PUNYCODE_BASE-t))));						q = (q-t) / (PUNYCODE_BASE-t);					}					ret.push_back(encodeDigit(q));										bias = adapt(delta, h+1, h==b);					delta = 0;					h++;				}			}			delta++;			n++;		}				return "xn--" + ret;	}	protected:	/**	 * BOMなしのUTF8文字列(UTF8-N)を、UTF32コードポイント列に変換する。	 *	 * @param codepoints [out] 変換されたコードポイントが格納される。	 * @param utf8 [in] 変換対象文字列	 * @return 成功すればtrue。不正なシーケンスが存在して完全に変換できなかった場合はfalse。	 */	static bool utf8ToUtf32(std::vector<unsigned int>& codepoints,							const char* utf8)	{		if (!utf8 || !utf8[0])		return false;				unsigned char* p;		unsigned int cp;		unsigned int byteval;		int cprestbytes;				cprestbytes = 0;		for (p=(unsigned char*)utf8; *p; p++)		{			byteval = *p;			if (byteval & 0x80)			{				// 1xxxxxxx				if (cprestbytes > 0)				{					// trailing bytes					if ((byteval & 0xC0) == 0x80)					{						// 10xxxxxx ... trailing bytes						cp = (cp << 6) | (byteval & 0x3F);						cprestbytes--;						if (cprestbytes <= 0)						{							codepoints.push_back(cp);						}					}					else					{						return false;					}				}				else				{					// leading byte					if ((byteval & 0xE0) == 0xC0)					{						// 110xxxxx						cp = (byteval & 0x1F);						cprestbytes = 1;					}					else if ((byteval & 0xF0) == 0xE0)					{						// 1110xxxx						cp = (byteval & 0x0F);						cprestbytes = 2;					} 					else if ((byteval & 0xF8) == 0xF0)					{						// 11110xxx						cp = (byteval & 0x07);						cprestbytes = 3;					}					else if ((byteval & 0xFC) == 0xF8)					{						// 111110xx						cp = (byteval & 0x03);						cprestbytes = 4;					}					else if ((byteval & 0xFE) == 0xFC)					{						// 1111110x						cp = (byteval & 0x01);						cprestbytes = 5;					}					else					{						// error.						return false;					}				}			}			else			{				if (cprestbytes <= 0)				{					// codepoint 0x00-0x7f					codepoints.push_back((unsigned int)*p);				}				else				{					// error					return false;				}			}		}				return (cprestbytes == 0);	}		/**	 * Unicodeコードポイント列を、UTF-8文字列に変換する。	 * @param utf8 [out] 変換されたBOMなしUTF-8文字列が格納される	 * @param codepoints [in] Unicodeコードポイント列	 * @return 成功すればtrue、失敗するとfalse	 */	static bool utf32ToUtf8(std::string& utf8,							const std::vector<unsigned int>& codepoints)	{		std::vector<unsigned int>::const_iterator it;		std::vector<unsigned int>::const_iterator itend = codepoints.end();				unsigned int cp;				for (it=codepoints.begin(); it!=itend; ++it)		{			cp = *it;						if (cp < 0x80)			{				// ASCII codepoint. pass it through.				utf8.push_back((char)(unsigned char)cp);							}			else if (cp < 0x800)			{				// 2byte sequence				// 110xxxxx 10xxxxxx				utf8.push_back((char)(unsigned char)(((cp & 0x07C0) >> 6) | 0xC0));				utf8.push_back((char)(unsigned char)((cp & 0x3F) | 0x80));			}			else if (cp < 0xD800)			{				// first half of 3byte sequence				// 1110xxxx 10xxxxxx 10xxxxxx				utf8.push_back((char)(unsigned char)(((cp & 0xF000) >> 12) | 0xE0));				utf8.push_back((char)(unsigned char)(((cp & 0xFC0) >> 6) | 0x80));				utf8.push_back((char)(unsigned char)((cp & 0x3F) | 0x80));							}			else if (cp < 0xE000)			{				// surrogate code point. error.				return false;			}			else if (cp < 0x10000)			{				// latter half of 3byte sequence				utf8.push_back((char)(unsigned char)(((cp & 0xF000) >> 12) | 0xE0));				utf8.push_back((char)(unsigned char)(((cp & 0xFC0) >> 6) | 0x80));				utf8.push_back((char)(unsigned char)((cp & 0x3F) | 0x80));							}			else if (cp < 0x100000)			{				// 4byte sequence				// 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx				utf8.push_back((char)(unsigned char)(((cp & 0x1C0000) >> 18) | 0xF0));				utf8.push_back((char)(unsigned char)(((cp & 0x3F000) >> 12) | 0x80));				utf8.push_back((char)(unsigned char)(((cp & 0xFC0) >> 6) | 0x80));				utf8.push_back((char)(unsigned char)((cp & 0x3F) | 0x80));							}			else if (cp < 0x200000)			{				// 5byte sequence				// 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx				utf8.push_back((char)(unsigned char)(((cp & 0x3000000) >> 24) | 0xF8));				utf8.push_back((char)(unsigned char)(((cp & 0xFC0000) >> 18) | 0x80));				utf8.push_back((char)(unsigned char)(((cp & 0x3F000) >> 12) | 0x80));				utf8.push_back((char)(unsigned char)(((cp & 0xFC0) >> 6) | 0x80));				utf8.push_back((char)(unsigned char)((cp & 0x3F) | 0x80));							}			else if (cp < 0x80000000)			{				// 6byte sequence				// 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx				utf8.push_back((char)(unsigned char)(((cp & 0x40000000) >> 30) | 0xFC));				utf8.push_back((char)(unsigned char)(((cp & 0x3F000000) >> 24) | 0x80));				utf8.push_back((char)(unsigned char)(((cp & 0xFC0000) >> 18) | 0x80));				utf8.push_back((char)(unsigned char)(((cp & 0x3F000) >> 12) | 0x80));				utf8.push_back((char)(unsigned char)(((cp & 0xFC0) >> 6) | 0x80));				utf8.push_back((char)(unsigned char)((cp & 0x3F) | 0x80));							}			else			{				// これ以上はUTF8で表せない。				return false;			}		}				return true;	}		static unsigned int adapt(unsigned int delta,							  unsigned int numpoints,							  bool firsttime)	{		unsigned int k, deltamin;				if (firsttime)		{			delta /= PUNYCODE_DAMP;		}		else		{			delta /= 2;		}		delta += (delta / numpoints);				k = 0;		deltamin = ((PUNYCODE_BASE - PUNYCODE_TMIN) * PUNYCODE_TMAX) / 2;		while (delta > deltamin)		{			delta /= (PUNYCODE_BASE - PUNYCODE_TMIN);			k += PUNYCODE_BASE;		}				return (k + (((PUNYCODE_BASE-PUNYCODE_TMIN+1)*delta) / (delta+PUNYCODE_SKEW)));	}		// calc (a + b * c).	// return true if no overflow occured. else false.	static bool calcMulAdd(unsigned int& res,						   unsigned int a,						   unsigned int b,						   unsigned int c)	{		if (b > ((UINT_MAX - a) / c))		{			return false;		}				res = a + b * c;		return true;	}		static char encodeDigit(unsigned int val)	{		return (char)(unsigned char)((val + 22 + 75*(val<26)) & 0xff);	}		static unsigned int decodeDigit(unsigned int cp)	{		return (cp-48 < 10 ? cp-22 : cp-65 < 26 ? cp-65 : cp-97<26 ? cp-97 : PUNYCODE_BASE);	}};#endif